<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SignSpeak - BISINDO Detection (CNN)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body class="bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-5xl font-bold text-white mb-2">ü§ü SignSpeak</h1>
            <p class="text-gray-300 text-lg">BISINDO Detection System (CNN Only)</p>
        </div>

        <!-- Main Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <!-- Camera Feed -->
            <div class="lg:col-span-2">
                <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-6 shadow-2xl relative">
                    <!-- Loading Overlay -->
                    <div id="statusOverlay" class="absolute inset-0 bg-black/80 flex items-center justify-center rounded-2xl z-10">
                        <div class="text-center">
                            <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-white mx-auto mb-4"></div>
                            <p class="text-white text-xl">Memuat kamera...</p>
                        </div>
                    </div>

                    <!-- Video Container -->
                    <div class="relative bg-black rounded-xl overflow-hidden" style="height: 480px;">
                        <video id="video" class="hidden"></video>
                        <canvas id="output" class="w-full h-full object-contain"></canvas>
                        
                        <!-- Mode Badge -->
                        <div class="absolute top-4 right-4 bg-indigo-600 text-white px-4 py-2 rounded-full font-bold shadow-lg">
                            CNN MODE
                        </div>

                        <!-- Hand Count -->
                        <div id="handCount" class="absolute top-4 left-4 bg-green-600 text-white px-4 py-2 rounded-full font-bold shadow-lg hidden">
                            üñêÔ∏è <span id="handCountText">0</span> Tangan
                        </div>

                        <!-- FPS Counter -->
                        <div class="absolute bottom-4 right-4 bg-black/60 text-white px-3 py-1 rounded-lg text-sm font-mono">
                            FPS: <span id="fpsCounter">0</span>
                        </div>

                        <!-- Crop Preview (Debug) -->
                        <canvas id="debugCrop" class="absolute bottom-4 left-4 border-2 border-yellow-400 rounded hidden" width="100" height="100"></canvas>
                    </div>

                    <!-- Status Bar -->
                    <div class="mt-4 bg-white/5 rounded-lg p-3">
                        <p id="status" class="text-gray-300 text-sm">Menunggu...</p>
                    </div>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="space-y-6">
                
                <!-- Prediction Result -->
                <div class="bg-gradient-to-br from-green-500 to-emerald-600 rounded-2xl p-6 shadow-2xl text-center">
                    <p class="text-white/80 text-sm mb-2">Prediksi:</p>
                    <p id="predictResult" class="text-5xl font-bold text-white mb-2">-</p>
                    <p id="predictConfidence" class="text-white/90 text-lg">-</p>
                    <div id="handDetectionStatus" class="mt-3 text-white/70 text-sm">
                        ‚è≥ Menunggu tangan...
                    </div>
                </div>

                <!-- Prediction Settings -->
                <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-6 shadow-2xl">
                    <h3 class="text-white font-bold mb-4">‚öôÔ∏è Pengaturan</h3>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="text-white text-sm mb-2 block">Interval Prediksi (ms)</label>
                            <input type="range" id="intervalSlider" min="300" max="1500" value="800" step="100" 
                                   class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <div class="text-white/70 text-xs mt-1 text-center">
                                <span id="intervalValue">800</span> ms
                            </div>
                        </div>

                        <div>
                            <label class="text-white text-sm mb-2 block">Min Confidence untuk Tampil</label>
                            <input type="range" id="confidenceSlider" min="0" max="100" value="30" step="5" 
                                   class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <div class="text-white/70 text-xs mt-1 text-center">
                                <span id="confidenceValue">30</span>%
                            </div>
                        </div>

                        <div class="flex items-center justify-between bg-black/30 rounded-lg p-3">
                            <span class="text-white text-sm">Hanya Prediksi Saat Ada Tangan</span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="handRequiredToggle" checked class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div>
                            </label>
                        </div>

                        <div class="flex items-center justify-between bg-black/30 rounded-lg p-3">
                            <span class="text-white text-sm">Tampilkan Preview Crop (Debug)</span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="debugCropToggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-yellow-600"></div>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Word Builder -->
                <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-6 shadow-2xl">
                    <h3 class="text-white font-bold mb-4">üìù Susun Kata</h3>
                    
                    <div class="bg-black/30 rounded-lg p-4 mb-3 text-center min-h-[60px] flex items-center justify-center">
                        <p id="wordOutput" class="text-3xl font-bold text-white break-all">---</p>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-3">
                        <button id="addWordBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg transition">
                            ‚ûï Tambah
                        </button>
                        <button id="clearWordBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg transition">
                            üóëÔ∏è Hapus
                        </button>
                    </div>
                    <p class="text-white/60 text-xs mt-3">üí° Minimal confidence: 70%</p>
                </div>

                <!-- Upload Image -->
                <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-6 shadow-2xl">
                    <h3 class="text-white font-bold mb-4">üì§ Upload Gambar</h3>
                    <input type="file" id="imageInput" accept="image/*" class="w-full text-white mb-3 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 file:cursor-pointer"/>
                    <button id="predictImageBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg transition">
                        üîÆ Prediksi Gambar
                    </button>
                </div>

            </div>
        </div>
    </div>

    <script>
// ===============================================
// SignSpeak Frontend - CNN ONLY (FIXED)
// ===============================================
const API_BASE = "http://127.0.0.1:5000";

// --- DOM Elements ---
const videoElement = document.getElementById("video");
const canvasElement = document.getElementById("output");
const statusOverlay = document.getElementById("statusOverlay");
const predictResult = document.getElementById("predictResult");
const predictConfidence = document.getElementById("predictConfidence");
const statusText = document.getElementById("status");
const handCount = document.getElementById("handCount");
const handCountText = document.getElementById("handCountText");
const handDetectionStatus = document.getElementById("handDetectionStatus");
const fpsCounter = document.getElementById("fpsCounter");
const debugCrop = document.getElementById("debugCrop");
const debugCropCtx = debugCrop.getContext("2d");

const intervalSlider = document.getElementById("intervalSlider");
const intervalValue = document.getElementById("intervalValue");
const confidenceSlider = document.getElementById("confidenceSlider");
const confidenceValue = document.getElementById("confidenceValue");
const handRequiredToggle = document.getElementById("handRequiredToggle");
const debugCropToggle = document.getElementById("debugCropToggle");

const wordOutput = document.getElementById("wordOutput");
const clearWordBtn = document.getElementById("clearWordBtn");
const addWordBtn = document.getElementById("addWordBtn");

const imageInput = document.getElementById("imageInput");
const predictImageBtn = document.getElementById("predictImageBtn");

const context = canvasElement.getContext("2d");

// --- Global State ---
let handsDetected = false;
let lastHandLandmarks = null; // Simpan landmark untuk cropping
let cnnIntervalId = null;
let currentWord = "";
let lastPredictedLabel = "";
let lastPredictedConfidence = 0;
let backendReady = false;
let isProcessingCNN = false;
let consecutiveErrors = 0;

// Settings
let CNN_PREDICT_INTERVAL = 800;
let MIN_CONFIDENCE_DISPLAY = 0.30; // Turun dari 0.50 ke 0.30
let MIN_CONFIDENCE_FOR_ADD = 0.70;
let REQUIRE_HAND_FOR_PREDICTION = true;

const MAX_CONSECUTIVE_ERRORS = 5;

// FPS Tracking
let frameCount = 0;
let lastFpsUpdate = Date.now();

// --- Canvas Setup ---
const VIDEO_WIDTH = 640;
const VIDEO_HEIGHT = 480;
canvasElement.width = VIDEO_WIDTH;
canvasElement.height = VIDEO_HEIGHT;

// ======================================================
// Settings Event Listeners
// ======================================================
intervalSlider.addEventListener('input', (e) => {
    CNN_PREDICT_INTERVAL = parseInt(e.target.value);
    intervalValue.textContent = CNN_PREDICT_INTERVAL;
    
    // Restart CNN loop with new interval
    if (cnnIntervalId) {
        stopCnnLoop();
        startCnnLoop();
    }
});

confidenceSlider.addEventListener('input', (e) => {
    MIN_CONFIDENCE_DISPLAY = parseInt(e.target.value) / 100;
    confidenceValue.textContent = e.target.value;
});

handRequiredToggle.addEventListener('change', (e) => {
    REQUIRE_HAND_FOR_PREDICTION = e.target.checked;
    showMessage(REQUIRE_HAND_FOR_PREDICTION ? 
        "‚úÖ Hanya prediksi saat ada tangan" : 
        "‚ö†Ô∏è Prediksi terus menerus");
});

debugCropToggle.addEventListener('change', (e) => {
    if (e.target.checked) {
        debugCrop.classList.remove('hidden');
        showMessage("üêõ Debug crop preview aktif");
    } else {
        debugCrop.classList.add('hidden');
        showMessage("Debug crop preview nonaktif");
    }
});

// ======================================================
// Helper Functions
// ======================================================
function showMessage(message, isError = false) {
    statusText.textContent = `Status: ${message}`;
    statusText.className = isError ? "text-red-400 text-sm font-semibold" : "text-gray-300 text-sm";
    console.log(isError ? "‚ùå" : "‚ÑπÔ∏è", message);
}

function updateFPS() {
    frameCount++;
    const now = Date.now();
    const elapsed = now - lastFpsUpdate;
    
    if (elapsed >= 1000) {
        const fps = Math.round((frameCount * 1000) / elapsed);
        fpsCounter.textContent = fps;
        frameCount = 0;
        lastFpsUpdate = now;
    }
}

// Helper function to get SQUARE bounding box from hand landmarks
function getHandBoundingBox(landmarks) {
    let minX = 1, minY = 1, maxX = 0, maxY = 0;
    
    for (const landmark of landmarks) {
        if (landmark.x < minX) minX = landmark.x;
        if (landmark.y < minY) minY = landmark.y;
        if (landmark.x > maxX) maxX = landmark.x;
        if (landmark.y > maxY) maxY = landmark.y;
    }
    
    // Calculate dimensions
    const width = maxX - minX;
    const height = maxY - minY;
    
    // Add generous padding (40%)
    const padding = 0.4;
    const paddedWidth = width * (1 + padding * 2);
    const paddedHeight = height * (1 + padding * 2);
    
    // Use the larger dimension to make it SQUARE
    const size = Math.max(paddedWidth, paddedHeight);
    
    // Center the square around the hand
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Calculate square boundaries
    let x1 = centerX - size / 2;
    let y1 = centerY - size / 2;
    let x2 = centerX + size / 2;
    let y2 = centerY + size / 2;
    
    // Clamp to canvas bounds
    x1 = Math.max(0, x1);
    y1 = Math.max(0, y1);
    x2 = Math.min(1, x2);
    y2 = Math.min(1, y2);
    
    return { 
        x: x1, 
        y: y1, 
        width: x2 - x1, 
        height: y2 - y1,
        centerX: centerX,
        centerY: centerY
    };
}

async function fetchApi(url, options = {}) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 8000);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorBody = await response.json().catch(() => ({}));
            throw new Error(errorBody.error || response.statusText);
        }
        return response.json();
    } catch (err) {
        clearTimeout(timeoutId);
        if (err.name === 'AbortError') {
            throw new Error('Request timeout');
        }
        throw err;
    }
}

// ======================================================
// MediaPipe Hands Setup
// ======================================================
const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
});

hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.6,
});

hands.onResults((results) => {
    // Clear canvas
    context.save();
    context.clearRect(0, 0, canvasElement.width, canvasElement.height);
    context.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

    // Check if hands detected
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handsDetected = true;
        lastHandLandmarks = results.multiHandLandmarks;
        const handCountVal = results.multiHandLandmarks.length;
        
        handCount.classList.remove("hidden");
        handCountText.textContent = handCountVal;
        handDetectionStatus.innerHTML = `‚úÖ ${handCountVal} tangan terdeteksi`;

        // Draw hand landmarks
        results.multiHandLandmarks.forEach((landmarks, index) => {
            const connectionColor = index === 0 ? "#00FF00" : "#FFC300";
            const landmarkColor = index === 0 ? "#FF0000" : "#FFFFFF";
            
            drawConnectors(context, landmarks, HAND_CONNECTIONS, { 
                color: connectionColor, 
                lineWidth: 3 
            });
            drawLandmarks(context, landmarks, { 
                color: landmarkColor, 
                lineWidth: 2,
                radius: 3
            });
            
            // Draw bounding box for debugging
            const bbox = getHandBoundingBox(landmarks);
            context.strokeStyle = connectionColor;
            context.lineWidth = 2;
            context.strokeRect(
                bbox.x * canvasElement.width,
                bbox.y * canvasElement.height,
                bbox.width * canvasElement.width,
                bbox.height * canvasElement.height
            );
        });
    } else {
        handsDetected = false;
        lastHandLandmarks = null;
        handCount.classList.add("hidden");
        handDetectionStatus.innerHTML = "‚è≥ Menunggu tangan...";
    }

    context.restore();
    updateFPS();
});

// ======================================================
// Camera Setup
// ======================================================
const cam = new Camera(videoElement, {
    onFrame: async () => {
        try {
            await hands.send({ image: videoElement });
        } catch (err) {
            console.error("MediaPipe error:", err);
        }
    },
    width: VIDEO_WIDTH,
    height: VIDEO_HEIGHT,
});

cam.start().then(() => {
    statusOverlay.style.opacity = "0";
    setTimeout(() => {
        statusOverlay.style.display = "none";
    }, 300);
    showMessage("‚úÖ Kamera siap. Checking backend...");
    checkBackendAndStart();
}).catch((err) => {
    showMessage(`‚ùå Gagal akses kamera: ${err.message}`, true);
    statusOverlay.style.display = "none";
});

// ======================================================
// Backend Health Check
// ======================================================
async function checkBackendAndStart() {
    try {
        console.log("üîç Checking backend at:", API_BASE);
        const response = await fetch(`${API_BASE}/health`, { 
            method: 'GET',
            cache: 'no-cache'
        });
        const data = await response.json();
        
        console.log("‚úÖ Backend response:", data);
        
        if (data.status === "healthy" && data.cnn_ready) {
            backendReady = true;
            consecutiveErrors = 0;
            showMessage("‚úÖ Backend terhubung. CNN Mode aktif!");
            startCnnLoop();
        } else {
            backendReady = false;
            showMessage("‚ö†Ô∏è Model CNN belum dimuat. Cek backend!", true);
            // Retry after 3 seconds
            setTimeout(checkBackendAndStart, 3000);
        }
    } catch (err) {
        backendReady = false;
        console.error("‚ùå Backend error:", err);
        showMessage(`‚ùå Backend tidak terhubung: ${err.message}`, true);
        // Retry after 5 seconds
        setTimeout(checkBackendAndStart, 5000);
    }
}

// ======================================================
// CNN Loop
// ======================================================
function startCnnLoop() {
    if (cnnIntervalId || !backendReady) return;
    
    cnnIntervalId = setInterval(() => {
        // Check conditions
        const shouldPredict = !isProcessingCNN && 
                             backendReady && 
                             (!REQUIRE_HAND_FOR_PREDICTION || handsDetected);
        
        if (shouldPredict) {
            captureAndPredictCNN();
        }
    }, CNN_PREDICT_INTERVAL);
    
    console.log("üß† CNN loop started with interval:", CNN_PREDICT_INTERVAL);
}

function stopCnnLoop() {
    if (cnnIntervalId) {
        clearInterval(cnnIntervalId);
        cnnIntervalId = null;
        consecutiveErrors = 0;
        console.log("üõë CNN loop stopped");
    }
}

async function captureAndPredictCNN() {
    if (isProcessingCNN || !backendReady || videoElement.paused || videoElement.ended) return;
    
    // Check if hand is required but not detected
    if (REQUIRE_HAND_FOR_PREDICTION && !handsDetected) {
        predictResult.textContent = "-";
        predictConfidence.textContent = "Tunjukkan tangan";
        lastPredictedLabel = "";
        lastPredictedConfidence = 0;
        return;
    }
    
    if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
        stopCnnLoop();
        showMessage("‚ùå Terlalu banyak error. Refresh halaman.", true);
        return;
    }
    
    isProcessingCNN = true;
    
    try {
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");
        tempCanvas.width = 128;
        tempCanvas.height = 128;
        
        // If hand detected, crop to SQUARE hand area, otherwise use full frame
        if (lastHandLandmarks && lastHandLandmarks.length > 0) {
            // Get SQUARE bounding box of the primary hand (first hand)
            const bbox = getHandBoundingBox(lastHandLandmarks[0]);
            
            // Calculate source crop dimensions (in canvas pixels)
            const srcX = bbox.x * canvasElement.width;
            const srcY = bbox.y * canvasElement.height;
            const srcW = bbox.width * canvasElement.width;
            const srcH = bbox.height * canvasElement.height;
            
            // Since bbox is already square, just draw it directly
            // Draw directly to 128x128 (proper scaling, no distortion)
            tempCtx.drawImage(
                canvasElement,
                srcX, srcY, srcW, srcH,  // source: square crop from canvas
                0, 0, 128, 128           // destination: 128x128
            );
        } else {
            // No hand detected, use full frame (center crop to square)
            const size = Math.min(canvasElement.width, canvasElement.height);
            const offsetX = (canvasElement.width - size) / 2;
            const offsetY = (canvasElement.height - size) / 2;
            
            tempCtx.drawImage(
                canvasElement,
                offsetX, offsetY, size, size,  // source: center square
                0, 0, 128, 128                 // destination: 128x128
            );
        }
        
        const dataURL = tempCanvas.toDataURL("image/jpeg", 0.85);

        // Show debug crop preview if enabled
        if (debugCropToggle.checked) {
            debugCropCtx.clearRect(0, 0, 100, 100);
            debugCropCtx.drawImage(tempCanvas, 0, 0, 100, 100);
        }

        const out = await fetchApi(`${API_BASE}/predict`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image: dataURL.split(",")[1] }),
        });
        
        if (out && out.label) {
            const conf = out.confidence;
            
            // Only display if confidence is above threshold
            if (conf >= MIN_CONFIDENCE_DISPLAY) {
                predictResult.textContent = out.label;
                predictConfidence.textContent = `${(conf * 100).toFixed(1)}% (CNN)`;
                lastPredictedLabel = out.label;
                lastPredictedConfidence = conf;
            } else {
                predictResult.textContent = "?";
                predictConfidence.textContent = `${(conf * 100).toFixed(1)}% (Terlalu rendah)`;
                lastPredictedLabel = "";
                lastPredictedConfidence = conf;
            }
            
            consecutiveErrors = 0;
            
            // Debug log
            console.log(`Prediksi: ${out.label} (${(conf*100).toFixed(1)}%) - Display: ${conf >= MIN_CONFIDENCE_DISPLAY} - Hand Crop: ${!!lastHandLandmarks}`);
        }
    } catch (err) {
        consecutiveErrors++;
        console.error(`CNN error (${consecutiveErrors}/${MAX_CONSECUTIVE_ERRORS}):`, err.message);
        
        if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
            predictResult.textContent = "ERROR";
            predictConfidence.textContent = "Backend Down";
            lastPredictedLabel = "";
            lastPredictedConfidence = 0;
        }
    } finally {
        isProcessingCNN = false;
    }
}

// ======================================================
// Word Builder
// ======================================================
addWordBtn.onclick = () => {
    if (!lastPredictedLabel) {
        showMessage("‚ùå Tidak ada prediksi", true);
        return;
    }
    
    if (lastPredictedConfidence < MIN_CONFIDENCE_FOR_ADD) {
        showMessage(`‚ùå Confidence rendah: ${(lastPredictedConfidence * 100).toFixed(1)}%`, true);
        return;
    }
    
    if (currentWord.slice(-1) !== lastPredictedLabel) {
        currentWord += lastPredictedLabel;
        wordOutput.textContent = currentWord;
        showMessage(`‚úÖ Ditambahkan: ${lastPredictedLabel}`);
    } else {
        showMessage(`‚ö†Ô∏è Huruf '${lastPredictedLabel}' sudah ada di akhir`);
    }
};

clearWordBtn.onclick = () => {
    currentWord = "";
    wordOutput.textContent = "---";
    showMessage("üóëÔ∏è Kata dihapus");
};

// ======================================================
// Image Upload
// ======================================================
predictImageBtn.onclick = async () => {
    const file = imageInput.files[0];
    if (!file) {
        showMessage("‚ùå Pilih gambar!", true);
        return;
    }
    
    if (!backendReady) {
        showMessage("‚ùå Backend belum siap!", true);
        return;
    }
    
    showMessage("üì∏ Memproses...");
    predictImageBtn.disabled = true;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const base64Image = e.target.result.split(",")[1];
            const result = await fetchApi(`${API_BASE}/predict`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ image: base64Image }),
            });
            
            if (result && result.label) {
                predictResult.textContent = result.label;
                predictConfidence.textContent = `${(result.confidence * 100).toFixed(1)}% (Upload)`;
                lastPredictedLabel = result.label;
                lastPredictedConfidence = result.confidence;
                showMessage(`‚úÖ Prediksi: ${result.label}`);
            }
        } catch (err) {
            showMessage(`‚ùå Error: ${err.message}`, true);
        } finally {
            predictImageBtn.disabled = false;
        }
    };
    reader.readAsDataURL(file);
};

// ======================================================
// Initialize
// ======================================================
console.log("üöÄ SignSpeak Frontend initialized (CNN Only - Fixed)");
console.log("üì° API Base:", API_BASE);
    </script>
</body>
</html>